import "./chunk-UV5CTPV7.js";

// node_modules/illusory/dist/index.esm.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var BORDER_RADIUS_REGEX = /^(\d+(?:\.\d+)?)([^\d\s.]+)(?:\s+(\d+(?:\.\d+)?)([^\d\s.]+))?$/;
function parseBorderRadius(borderRadius) {
  var _a2, _b, _c, _d;
  const parsedBorderRadius = BORDER_RADIUS_REGEX.exec(borderRadius);
  let x;
  let y;
  x = {
    value: +((_a2 = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[1]) !== null && _a2 !== void 0 ? _a2 : 0),
    unit: (_b = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[2]) !== null && _b !== void 0 ? _b : "px"
  };
  if (parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[3])
    y = {
      value: +((_c = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[3]) !== null && _c !== void 0 ? _c : 0),
      unit: (_d = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[4]) !== null && _d !== void 0 ? _d : "px"
    };
  else
    y = Object.assign({}, x);
  return {
    x,
    y
  };
}
function stringifyBorderRadius(radii) {
  return `${radii.x.value}${radii.x.unit} ${radii.y.value}${radii.y.unit}`;
}
function borderRadiusHandler(delta, borderRadius) {
  const radii = parseBorderRadius(borderRadius);
  if (radii.x.unit !== "%")
    radii.x.value = radii.x.value * delta.inverseScaleX;
  if (radii.y.unit !== "%")
    radii.y.value = radii.y.value * delta.inverseScaleY;
  return stringifyBorderRadius(radii);
}
function parseTransformOrigin(originString) {
  const origin = originString.split(" ").map(parseFloat);
  return {
    x: origin[0],
    y: origin[1]
  };
}
var DELTA_PASS_THROUGH_HANDLER = (_, __, thisStyle) => thisStyle;
function getDelta(start, end) {
  const origin = parseTransformOrigin(start.getStyle("transformOrigin"));
  const scaleX = end.rect.width / start.rect.width;
  const scaleY = end.rect.height / start.rect.height;
  const inverseScaleX = start.rect.width / end.rect.width;
  const inverseScaleY = start.rect.height / end.rect.height;
  const originDisplacementX = origin.x / start.rect.width * (end.rect.width * (1 - inverseScaleX));
  const originDisplacementY = origin.y / start.rect.height * (end.rect.height * (1 - inverseScaleY));
  const x = end.rect.left - start.rect.left + originDisplacementX;
  const y = end.rect.top - start.rect.top + originDisplacementY;
  return {
    x,
    y,
    scaleX,
    scaleY,
    inverseScaleX,
    inverseScaleY
  };
}
function format(source) {
  if (source && source.constructor === Array) {
    var values = source.filter(function(value) {
      return typeof value === "number";
    }).filter(function(value) {
      return !isNaN(value);
    });
    if (source.length === 6 && values.length === 6) {
      var matrix = identity();
      matrix[0] = values[0];
      matrix[1] = values[1];
      matrix[4] = values[2];
      matrix[5] = values[3];
      matrix[12] = values[4];
      matrix[13] = values[5];
      return matrix;
    } else if (source.length === 16 && values.length === 16) {
      return source;
    }
  }
  throw new TypeError("Expected a `number[]` with length 6 or 16.");
}
function fromString(source) {
  if (typeof source === "string") {
    var match = source.match(/matrix(3d)?\(([^)]+)\)/);
    if (match) {
      var raw = match[2].split(", ").map(parseFloat);
      return format(raw);
    }
  }
  throw new TypeError("Expected a string containing `matrix()` or `matrix3d()");
}
function identity() {
  var matrix = [];
  for (var i = 0; i < 16; i++) {
    i % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix;
}
function multiply(matrixA, matrixB) {
  var fma = format(matrixA);
  var fmb = format(matrixB);
  var product = [];
  for (var i = 0; i < 4; i++) {
    var row = [fma[i], fma[i + 4], fma[i + 8], fma[i + 12]];
    for (var j = 0; j < 4; j++) {
      var k = j * 4;
      var col = [fmb[k], fmb[k + 1], fmb[k + 2], fmb[k + 3]];
      var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i + k] = result;
    }
  }
  return product;
}
function scale(scalar, scalarY) {
  var matrix = identity();
  matrix[0] = scalar;
  matrix[5] = typeof scalarY === "number" ? scalarY : scalar;
  return matrix;
}
function toString(source) {
  return "matrix3d(" + format(source).join(", ") + ")";
}
function translate(distanceX, distanceY) {
  var matrix = identity();
  matrix[12] = distanceX;
  if (distanceY) {
    matrix[13] = distanceY;
  }
  return matrix;
}
var IDENTITY_MATRIX = identity();
function transformHandler(delta, deltaStyle) {
  let originalMatrixOfDeltaElement;
  if (deltaStyle.startsWith("matrix"))
    originalMatrixOfDeltaElement = fromString(deltaStyle);
  else
    originalMatrixOfDeltaElement = IDENTITY_MATRIX;
  const deltaMatrix = [translate(delta.x, delta.y), originalMatrixOfDeltaElement, scale(delta.scaleX, delta.scaleY)];
  let transformString;
  try {
    transformString = toString(deltaMatrix.reduce(multiply));
  } catch (e) {
    if (process && true && true)
      console.error("[illusory] Failed to construct transform matrix. Is the element in the DOM?");
    return "none";
  }
  return transformString;
}
var DEFAULT_OPTIONS = {
  element: {
    includeChildren: true,
    ignoreTransparency: ["img"]
  },
  zIndex: 1,
  compositeOnly: false,
  duration: "300ms",
  easing: "ease",
  relativeTo: [document]
};
var RGBA_REGEX = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([01](?:\.\d+)?)\)$/i;
var isHex = (hex) => /^#([a-f0-9]{4}){1,2}$/i.test(hex);
var hexChunkSize = (hex) => Math.floor((hex.length - 1) / 3);
var separateHex = (hex) => hex.match(new RegExp(`.{${hexChunkSize(hex)}}`, "g"));
var hexToDec = (hex) => parseInt(hex.repeat(2 / hex.length), 16);
var getAlphaFloat = (a) => +(a / 256).toFixed(2);
var hexToRGBA = (hexArr) => {
  const [r, g, b, a] = hexArr.map(hexToDec);
  return [r, g, b, getAlphaFloat(a)];
};
function parseRGBA(color) {
  const rgba = RGBA_REGEX.exec(color);
  let r;
  let g;
  let b;
  let a;
  if (rgba) {
    [r, g, b, a] = rgba.slice(1, 5).map(parseFloat);
  } else if (isHex(color)) {
    const hexArray = separateHex(color.slice(1));
    if (!hexArray)
      return false;
    [r, g, b, a] = hexToRGBA(hexArray);
  } else
    return false;
  return { r, g, b, a };
}
var isHTMLOrSVG = (node) => node instanceof HTMLElement || node instanceof SVGElement;
function toKebab(str) {
  return str.split(/(?=[A-Z])/).join("-").toLowerCase();
}
function filterDataAttributes(element, filterFunction) {
  Object.keys(element.dataset).forEach((key) => {
    const attr = `data-${toKebab(key)}`;
    if (attr.indexOf("data-illusory") === 0)
      return;
    if (!filterFunction || !filterFunction(attr))
      element.removeAttribute(attr);
  });
}
function copyStyles(source, target) {
  const styles = window.getComputedStyle(source);
  if (styles.cssText !== "")
    target.style.cssText = styles.cssText;
  else {
    let mockCssText = "";
    for (let i = 0; i < styles.length; i++) {
      mockCssText += `${styles[i]}: ${styles.getPropertyValue(styles[i])}; `;
    }
    target.style.cssText = mockCssText;
  }
  target.style.transformOrigin = styles.transformOrigin;
}
function duplicateNode(node, options, depth = 0) {
  let clone = node.cloneNode(false);
  if (isHTMLOrSVG(node)) {
    copyStyles(node, clone);
    if (options.preserveDataAttributes !== true)
      filterDataAttributes(clone, options.preserveDataAttributes);
  }
  if (typeof options.processClone === "function") {
    const processedClone = options.processClone(clone, depth);
    if (processedClone)
      clone = processedClone;
    else
      return null;
  }
  if (options.includeChildren) {
    node.childNodes.forEach((child) => {
      const duplicatedNode = duplicateNode(child, options, depth + 1);
      if (duplicatedNode)
        clone.appendChild(duplicatedNode);
    });
  }
  return clone;
}
function flushCSSUpdates(el1, el2) {
  el1.clone.clientWidth;
  el2 === null || el2 === void 0 ? void 0 : el2.clone.clientWidth;
}
function buildTransitionString(options) {
  if (options.compositeOnly)
    return `transform ${options.duration} ${options.easing} 0s, opacity ${options.duration} ${options.easing} 0s`;
  else
    return `all ${options.duration} ${options.easing} 0s`;
}
var IllusoryElement = class {
  constructor(el, options) {
    var _a2, _b;
    this.originalStyle = {};
    this.deltaHandlers = {
      transform: transformHandler,
      borderTopLeftRadius: borderRadiusHandler,
      borderTopRightRadius: borderRadiusHandler,
      borderBottomRightRadius: borderRadiusHandler,
      borderBottomLeftRadius: borderRadiusHandler
    };
    this.isAttached = false;
    this.natural = el;
    this.initialStyleAttributeValue = this.natural.getAttribute("style");
    this._shouldIgnoreTransparency = (_a2 = options === null || options === void 0 ? void 0 : options.ignoreTransparency) !== null && _a2 !== void 0 ? _a2 : DEFAULT_OPTIONS.element.ignoreTransparency;
    this.natural.style.transition = "none";
    this.natural.style.animation = "none";
    {
      const originalNaturalTransform = this.natural.style.transform;
      this.natural.style.transform = "none";
      this.rect = this.natural.getBoundingClientRect();
      this.natural.style.transform = originalNaturalTransform;
    }
    this.clone = duplicateNode(this.natural, {
      includeChildren: (_b = options === null || options === void 0 ? void 0 : options.includeChildren) !== null && _b !== void 0 ? _b : DEFAULT_OPTIONS.element.includeChildren,
      preserveDataAttributes: options === null || options === void 0 ? void 0 : options.preserveDataAttributes,
      processClone: options === null || options === void 0 ? void 0 : options.processClone
    });
    this.setStyle("left", "auto");
    this.setStyle("right", "auto");
    this.setStyle("top", "auto");
    this.setStyle("bottom", "auto");
    this.setStyle("margin", "0 0 0 0");
    this.setStyle("transition", "none");
    this.setStyle("animation", "none");
    this.setStyle("pointerEvents", "none");
    this.setStyle("position", "fixed");
    this.setStyle("left", `${this.rect.left}px`);
    this.setStyle("top", `${this.rect.top}px`);
    if (options === null || options === void 0 ? void 0 : options.attachImmediately)
      this.attach();
  }
  _makeCompositeOnly() {
    this.deltaHandlers = {
      transform: transformHandler,
      borderTopLeftRadius: DELTA_PASS_THROUGH_HANDLER,
      borderTopRightRadius: DELTA_PASS_THROUGH_HANDLER,
      borderBottomLeftRadius: DELTA_PASS_THROUGH_HANDLER,
      borderBottomRightRadius: DELTA_PASS_THROUGH_HANDLER
    };
  }
  get _ignoreTransparency() {
    if (this._shouldIgnoreTransparency === true)
      return true;
    if (Array.isArray(this._shouldIgnoreTransparency) && this._shouldIgnoreTransparency.indexOf(this.clone.tagName.toLowerCase()) !== -1)
      return true;
    return false;
  }
  _hasTransparentBackground() {
    if (this._ignoreTransparency)
      return false;
    const rgba = parseRGBA(this.getStyle("backgroundColor"));
    if (!rgba)
      return false;
    return rgba.a < 1;
  }
  _to(element) {
    const delta = getDelta(this, element);
    Object.keys(this.deltaHandlers).forEach((key) => {
      this.setStyle(key, this.deltaHandlers[key](delta, element.getStyle(key), this.getStyle(key)));
    });
  }
  _enableTransitions(options) {
    this.setStyle("transition", buildTransitionString(options));
  }
  _disableTransitions() {
    this.setStyle("transition", "none");
  }
  _setParent(element) {
    if (this.isAttached)
      this.detach();
    this.hideNatural();
    element.appendChild(this.clone);
    this.isAttached = true;
  }
  _resetNaturalStyleAttribute() {
    if (!this.initialStyleAttributeValue)
      this.natural.removeAttribute("style");
    else
      this.natural.setAttribute("style", this.initialStyleAttributeValue);
  }
  getStyle(property) {
    var _a2;
    return (_a2 = this.originalStyle[property]) !== null && _a2 !== void 0 ? _a2 : this.clone.style[property];
  }
  setStyle(property, value) {
    this.originalStyle[property] = this.getStyle(property);
    this.clone.style[property] = value;
  }
  waitFor(property) {
    return new Promise((resolve) => {
      const cb = (e) => __awaiter(this, void 0, void 0, function* () {
        if (property !== "any" && e.propertyName !== property)
          return;
        if (property === "any")
          yield new Promise((r) => requestAnimationFrame(r));
        this.clone.removeEventListener("transitionend", cb);
        resolve();
      });
      this.clone.addEventListener("transitionend", cb);
    });
  }
  hide() {
    this.setStyle("opacity", "0");
  }
  show() {
    this.setStyle("opacity", "1");
  }
  hideNatural() {
    this.natural.style.opacity = "0";
  }
  showNatural() {
    this.natural.style.opacity = "1";
  }
  flushCSS() {
    flushCSSUpdates(this);
  }
  attach() {
    this._setParent(document.body);
  }
  detach() {
    if (!this.isAttached)
      return;
    this.showNatural();
    this.flushCSS();
    this._resetNaturalStyleAttribute();
    this.clone.remove();
    this.isAttached = false;
  }
};
var targetManagers = /* @__PURE__ */ new Map();
var TargetManager = class _TargetManager {
  constructor(target, listener) {
    this.listeners = [];
    this.initialPositions = /* @__PURE__ */ new Map();
    this.target = target;
    this.add(listener);
  }
  static getCumulativeDelta(listener) {
    return listener.dependencies.reduce(({ x, y }, target) => {
      const delta = targetManagers.get(target).getDelta(listener);
      return {
        x: x + delta.x,
        y: y + delta.y
      };
    }, { x: 0, y: 0 });
  }
  get currentPosition() {
    return {
      x: this.target instanceof Document ? window.scrollX : this.target.scrollLeft,
      y: this.target instanceof Document ? window.scrollY : this.target.scrollTop
    };
  }
  getDelta(listener) {
    const initialPosition = this.initialPositions.get(listener);
    const currentPosition = this.currentPosition;
    return {
      x: initialPosition.x - currentPosition.x,
      y: initialPosition.y - currentPosition.y
    };
  }
  get listenerCount() {
    return this.listeners.length;
  }
  add(listener) {
    this.listeners.push(listener);
    this.initialPositions.set(listener, this.currentPosition);
  }
  remove(listener) {
    this.listeners.splice(this.listeners.indexOf(listener), 1);
    this.initialPositions.delete(listener);
  }
  dispatch() {
    this.listeners.forEach((listener) => {
      const delta = _TargetManager.getCumulativeDelta(listener);
      listener.handler(delta);
    });
  }
};
var debounce = false;
var scrollHandler = (e) => {
  if (debounce)
    return;
  debounce = true;
  requestAnimationFrame(() => {
    debounce = false;
    const target = e.target;
    if (!targetManagers.has(target))
      return;
    targetManagers.get(target).dispatch();
  });
};
var ScrollManager = {
  add(listener) {
    listener.dependencies.forEach((target) => {
      if (!targetManagers.size)
        document.addEventListener("scroll", scrollHandler, true);
      if (targetManagers.has(target))
        targetManagers.get(target).add(listener);
      else
        targetManagers.set(target, new TargetManager(target, listener));
    });
  },
  remove(listener) {
    listener.dependencies.forEach((target) => {
      const manager = targetManagers.get(target);
      manager.remove(listener);
      if (!manager.listenerCount)
        targetManagers.delete(target);
    });
    if (!targetManagers.size)
      document.removeEventListener("scroll", scrollHandler, true);
  }
};
function createContainer(opts) {
  const container = document.createElement("div");
  container.style.position = "fixed";
  container.style.top = "0";
  container.style.left = "0";
  container.style.zIndex = opts.zIndex.toString();
  container.style.transition = `opacity ${opts.duration} ${opts.easing} 0s`;
  document.body.appendChild(container);
  const scrollListener = {
    dependencies: opts.relativeTo,
    handler({ x, y }) {
      container.style.transform = `translate(${x}px, ${y}px)`;
    }
  };
  ScrollManager.add(scrollListener);
  return {
    setOpacity(opacity) {
      container.style.opacity = opacity;
    },
    add(start, end) {
      [start, end].forEach((el) => {
        if (opts.compositeOnly)
          el._makeCompositeOnly();
        el._setParent(container);
        el.setStyle("opacity", 1);
      });
    },
    destroy(start, end, canceled) {
      return __awaiter(this, void 0, void 0, function* () {
        if (typeof opts.beforeDetach === "function") {
          yield opts.beforeDetach(start, end, canceled);
        }
        ScrollManager.remove(scrollListener);
        start.detach();
        end.detach();
        container.remove();
      });
    }
  };
}
function illusory(from, to, options) {
  const opts = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
  const convert = (target) => target instanceof IllusoryElement ? target : new IllusoryElement(target, opts.element);
  const start = convert(from);
  const end = convert(to);
  start.setStyle("zIndex", 1);
  end.setStyle("zIndex", 2);
  const container = createContainer(opts);
  container.add(start, end);
  container.setOpacity(start.getStyle("opacity"));
  const ref = {
    cancel: () => {
      throw new Error("Cancel called before assigned");
    }
  };
  return {
    finished: animate(start, end, container, opts, ref),
    cancel: () => {
      ref.cancel();
    }
  };
}
function animate(start, end, container, opts, cancelRef) {
  return new Promise((finished) => __awaiter(this, void 0, void 0, function* () {
    let canceled = false;
    const cancel = () => __awaiter(this, void 0, void 0, function* () {
      canceled = true;
      yield container.destroy(start, end, canceled);
      finished(canceled);
    });
    cancelRef.cancel = cancel;
    end.hide();
    end._to(start);
    if (typeof opts.beforeAnimate === "function")
      yield Promise.resolve(opts.beforeAnimate(start, end));
    if (canceled)
      return;
    start._enableTransitions(opts);
    end._enableTransitions(opts);
    flushCSSUpdates(start, end);
    start._to(end);
    end._to(end);
    if (!end._ignoreTransparency && (end._hasTransparentBackground() || opts.compositeOnly))
      start.hide();
    end.show();
    container.setOpacity(end.getStyle("opacity"));
    yield end.waitFor("any");
    if (canceled)
      return;
    yield container.destroy(start, end, canceled);
    finished(canceled);
  }));
}

// node_modules/v-shared-element/dist/es/index.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var sharedElementMixin = {
  data: function() {
    return {
      $_vSharedElement_triggers: [],
      $_vSharedElement_firstRender: true
    };
  },
  methods: {
    $keepSharedElementAlive: function(trigger2) {
      this.$data.$_vSharedElement_triggers.push(trigger2);
    }
  },
  activated: function() {
    if (this.$data.$_vSharedElement_firstRender)
      return this.$data.$_vSharedElement_firstRender = false;
    this.$data.$_vSharedElement_triggers.forEach(function(trigger2) {
      return trigger2();
    });
  }
};
var DEFAULT_OPTIONS2 = {
  easing: "ease",
  duration: "300ms",
  endDuration: "150ms",
  zIndex: 1,
  compositeOnly: false,
  includeChildren: true,
  ignoreTransparency: ["img"],
  restrictToViewport: true,
  restrictToRoutes: false
};
function hideElement(element) {
  element.style.animation = "none";
  element.style.transition = "none";
  element.style.opacity = "0";
}
function withinViewport(rect) {
  return rect.bottom >= 0 && rect.right >= 0 && rect.top <= window.innerHeight && rect.left <= window.innerWidth;
}
function createRouteGuard(sharedElementCandidates2, sharedElementCache2) {
  var SharedElementRouteGuard2 = function(to, from, next) {
    sharedElementCache2.clear();
    var subSharedElements = [];
    sharedElementCandidates2.forEach(function(candidate, id) {
      if (candidate.options.restrictToRoutes) {
        if (Array.isArray(candidate.options.restrictToRoutes)) {
          if (!candidate.options.restrictToRoutes.includes(to.path))
            return;
        } else if (typeof candidate.options.restrictToRoutes === "function") {
          if (!candidate.options.restrictToRoutes(to, from, id))
            return;
        }
      }
      if (candidate.options.restrictToViewport) {
        var bcr = candidate.element.getBoundingClientRect();
        if (!withinViewport(bcr))
          return;
      }
      var element = new IllusoryElement(candidate.element, {
        includeChildren: candidate.options.includeChildren,
        ignoreTransparency: candidate.options.ignoreTransparency,
        processClone: function(node, depth) {
          if (depth > 0 && (node instanceof HTMLElement || node instanceof SVGElement) && node.dataset.illusoryId && sharedElementCache2.has(node.dataset.illusoryId))
            subSharedElements.push(node);
          return node;
        }
      });
      sharedElementCache2.set(id, {
        id,
        element,
        options: candidate.options
      });
    });
    sharedElementCandidates2.clear();
    subSharedElements.forEach(function(el) {
      hideElement(el);
    });
    next();
  };
  var NuxtSharedElementRouteGuard2 = function(context) {
    var router = context.app.router;
    router.beforeEach(SharedElementRouteGuard2);
  };
  return { SharedElementRouteGuard: SharedElementRouteGuard2, NuxtSharedElementRouteGuard: NuxtSharedElementRouteGuard2 };
}
function nextFrame() {
  return new Promise(function(r) {
    return requestAnimationFrame(r);
  });
}
var sharedElementCandidates = /* @__PURE__ */ new Map();
var sharedElementCache = /* @__PURE__ */ new Map();
function trigger(activeElement, vnode, combinedOptions, id) {
  return __awaiter2(this, void 0, void 0, function() {
    var cachedElement, finished;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          activeElement.dataset.illusoryId = id;
          sharedElementCandidates.set(id, {
            element: activeElement,
            options: combinedOptions
          });
          cachedElement = sharedElementCache.get(id);
          if (!cachedElement)
            return [2];
          finished = illusory(cachedElement.element, activeElement, {
            element: {
              includeChildren: combinedOptions.includeChildren,
              ignoreTransparency: cachedElement.options.ignoreTransparency,
              processClone: function(node, depth) {
                if (depth > 0 && (node instanceof HTMLElement || node instanceof SVGElement) && node.dataset.illusoryId && sharedElementCache.has(node.dataset.illusoryId)) {
                  hideElement(node);
                }
                return node;
              }
            },
            compositeOnly: cachedElement.options.compositeOnly,
            duration: cachedElement.options.duration,
            zIndex: cachedElement.options.zIndex,
            easing: cachedElement.options.easing,
            relativeTo: [],
            beforeAnimate: function(from, to) {
              return __awaiter2(this, void 0, void 0, function() {
                return __generator(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      return [4, nextFrame()];
                    case 1:
                      _a3.sent();
                      to.rect = to.natural.getBoundingClientRect();
                      to.setStyle("left", "".concat(to.rect.left, "px"));
                      to.setStyle("top", "".concat(to.rect.top, "px"));
                      to._to(from);
                      return [4, nextFrame()];
                    case 2:
                      _a3.sent();
                      return [2];
                  }
                });
              });
            },
            beforeDetach: function(from, to) {
              if (combinedOptions.includeChildren || !combinedOptions.endDuration || parseFloat(combinedOptions.endDuration) <= 0)
                return;
              from.hide();
              to.showNatural();
              to.setStyle("transition", "opacity ".concat(combinedOptions.endDuration));
              to.hide();
              return to.waitFor("opacity");
            }
          }).finished;
          return [4, finished];
        case 1:
          _a2.sent();
          return [2];
      }
    });
  });
}
var $createIllusoryElement = function(el, opts) {
  return new IllusoryElement(el, opts);
};
var insertedMounted = function(options) {
  if (options === void 0) {
    options = {};
  }
  return function(activeElement, binding, vnode) {
    return __awaiter2(void 0, void 0, void 0, function() {
      var combinedOptions, id;
      var _a2;
      return __generator(this, function(_b) {
        combinedOptions = __assign(__assign(__assign({}, DEFAULT_OPTIONS2), options), binding.value);
        id = binding.arg;
        if (!id)
          throw new Error("Missing ID on a v-shared-element. For usage see: https://github.com/justintaddei/v-shared-element#readme");
        if ((_a2 = binding.value) === null || _a2 === void 0 ? void 0 : _a2.$keepSharedElementAlive)
          binding.value.$keepSharedElementAlive(function() {
            trigger(activeElement, vnode, combinedOptions, id);
          });
        trigger(activeElement, vnode, combinedOptions, id);
        return [2];
      });
    });
  };
};
var isVue3 = function(app) {
  return "config" in app && "globalProperties" in app.config;
};
var SharedElementDirective = {
  install: function(app, options) {
    if (!isVue3(app)) {
      app.prototype.$illusory = illusory;
      app.prototype.$createIllusoryElement = $createIllusoryElement;
      app.directive("shared-element", {
        inserted: insertedMounted(options)
      });
      return;
    }
    app.config.globalProperties.$illusory = illusory;
    app.config.globalProperties.$createIllusoryElement = $createIllusoryElement;
    app.directive("shared-element", {
      mounted: insertedMounted(options)
    });
  }
};
var createSharedElementDirective = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    install: function(app, _options) {
      return SharedElementDirective.install(app, options);
    }
  };
};
var _a = createRouteGuard(sharedElementCandidates, sharedElementCache);
var NuxtSharedElementRouteGuard = _a.NuxtSharedElementRouteGuard;
var SharedElementRouteGuard = _a.SharedElementRouteGuard;
export {
  NuxtSharedElementRouteGuard,
  SharedElementDirective,
  SharedElementRouteGuard,
  createSharedElementDirective,
  sharedElementMixin
};
/*! Bundled license information:

illusory/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
  (*! @license Rematrix v0.7.0
  
  	Copyright 2020 Julian Lloyd.
  
  	Permission is hereby granted, free of charge, to any person obtaining a copy
  	of this software and associated documentation files (the "Software"), to deal
  	in the Software without restriction, including without limitation the rights
  	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  	copies of the Software, and to permit persons to whom the Software is
  	furnished to do so, subject to the following conditions:
  
  	The above copyright notice and this permission notice shall be included in
  	all copies or substantial portions of the Software.
  
  	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  	THE SOFTWARE.
  *)
*/
//# sourceMappingURL=v-shared-element.js.map
