/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const BORDER_RADIUS_REGEX = /^(\d+(?:\.\d+)?)([^\d\s.]+)(?:\s+(\d+(?:\.\d+)?)([^\d\s.]+))?$/;
function parseBorderRadius(borderRadius) {
    var _a, _b, _c, _d;
    const parsedBorderRadius = BORDER_RADIUS_REGEX.exec(borderRadius);
    let x;
    let y;
    x = {
        value: +((_a = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[1]) !== null && _a !== void 0 ? _a : 0),
        unit: (_b = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[2]) !== null && _b !== void 0 ? _b : 'px'
    };
    if (parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[3])
        y = {
            value: +((_c = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[3]) !== null && _c !== void 0 ? _c : 0),
            unit: (_d = parsedBorderRadius === null || parsedBorderRadius === void 0 ? void 0 : parsedBorderRadius[4]) !== null && _d !== void 0 ? _d : 'px'
        };
    else
        y = Object.assign({}, x);
    return {
        x,
        y
    };
}
function stringifyBorderRadius(radii) {
    return `${radii.x.value}${radii.x.unit} ${radii.y.value}${radii.y.unit}`;
}

function borderRadiusHandler(delta, borderRadius) {
    const radii = parseBorderRadius(borderRadius);
    if (radii.x.unit !== '%')
        radii.x.value = radii.x.value * delta.inverseScaleX;
    if (radii.y.unit !== '%')
        radii.y.value = radii.y.value * delta.inverseScaleY;
    return stringifyBorderRadius(radii);
}

function parseTransformOrigin(originString) {
    const origin = originString.split(' ').map(parseFloat);
    return {
        x: origin[0],
        y: origin[1]
    };
}

const DELTA_PASS_THROUGH_HANDLER = (_, __, thisStyle) => thisStyle;
function getDelta(start, end) {
    const origin = parseTransformOrigin(start.getStyle('transformOrigin'));
    const scaleX = end.rect.width / start.rect.width;
    const scaleY = end.rect.height / start.rect.height;
    const inverseScaleX = start.rect.width / end.rect.width;
    const inverseScaleY = start.rect.height / end.rect.height;
    const originDisplacementX = (origin.x / start.rect.width) * (end.rect.width * (1 - inverseScaleX));
    const originDisplacementY = (origin.y / start.rect.height) * (end.rect.height * (1 - inverseScaleY));
    const x = end.rect.left - start.rect.left + originDisplacementX;
    const y = end.rect.top - start.rect.top + originDisplacementY;
    return {
        x,
        y,
        scaleX,
        scaleY,
        inverseScaleX,
        inverseScaleY
    };
}

/*! @license Rematrix v0.7.0

	Copyright 2020 Julian Lloyd.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format(source) {
  if (source && source.constructor === Array) {
    var values = source
      .filter(function (value) { return typeof value === 'number'; })
      .filter(function (value) { return !isNaN(value); });

    if (source.length === 6 && values.length === 6) {
      var matrix = identity();
      matrix[0] = values[0];
      matrix[1] = values[1];
      matrix[4] = values[2];
      matrix[5] = values[3];
      matrix[12] = values[4];
      matrix[13] = values[5];
      return matrix
    } else if (source.length === 16 && values.length === 16) {
      return source
    }
  }
  throw new TypeError('Expected a `number[]` with length 6 or 16.')
}

function fromString(source) {
  if (typeof source === 'string') {
    var match = source.match(/matrix(3d)?\(([^)]+)\)/);
    if (match) {
      var raw = match[2].split(', ').map(parseFloat);
      return format(raw)
    }
  }
  throw new TypeError('Expected a string containing `matrix()` or `matrix3d()')
}

function identity() {
  var matrix = [];
  for (var i = 0; i < 16; i++) {
    i % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix
}

function multiply(matrixA, matrixB) {
  var fma = format(matrixA);
  var fmb = format(matrixB);
  var product = [];

  for (var i = 0; i < 4; i++) {
    var row = [fma[i], fma[i + 4], fma[i + 8], fma[i + 12]];
    for (var j = 0; j < 4; j++) {
      var k = j * 4;
      var col = [fmb[k], fmb[k + 1], fmb[k + 2], fmb[k + 3]];
      var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];

      product[i + k] = result;
    }
  }

  return product
}

function scale(scalar, scalarY) {
  var matrix = identity();

  matrix[0] = scalar;
  matrix[5] = typeof scalarY === 'number' ? scalarY : scalar;

  return matrix
}

function toString(source) {
  return ("matrix3d(" + (format(source).join(', ')) + ")")
}

function translate(distanceX, distanceY) {
  var matrix = identity();
  matrix[12] = distanceX;

  if (distanceY) {
    matrix[13] = distanceY;
  }

  return matrix
}

const IDENTITY_MATRIX = identity();
function transformHandler(delta, deltaStyle) {
    let originalMatrixOfDeltaElement;
    if (deltaStyle.startsWith('matrix'))
        originalMatrixOfDeltaElement = fromString(deltaStyle);
    else
        originalMatrixOfDeltaElement = IDENTITY_MATRIX;
    const deltaMatrix = [translate(delta.x, delta.y), originalMatrixOfDeltaElement, scale(delta.scaleX, delta.scaleY)];
    let transformString;
    try {
        transformString = toString(deltaMatrix.reduce(multiply));
    }
    catch (e) {
        if (process && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test')
            console.error('[illusory] Failed to construct transform matrix. Is the element in the DOM?');
        return 'none';
    }
    return transformString;
}

const DEFAULT_OPTIONS = {
    element: {
        includeChildren: true,
        ignoreTransparency: ['img']
    },
    zIndex: 1,
    compositeOnly: false,
    duration: '300ms',
    easing: 'ease',
    relativeTo: [document]
};

const RGBA_REGEX = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([01](?:\.\d+)?)\)$/i;
const isHex = (hex) => /^#([a-f0-9]{4}){1,2}$/i.test(hex);
const hexChunkSize = (hex) => Math.floor((hex.length - 1) / 3);
const separateHex = (hex) => hex.match(new RegExp(`.{${hexChunkSize(hex)}}`, 'g'));
const hexToDec = (hex) => parseInt(hex.repeat(2 / hex.length), 16);
const getAlphaFloat = (a) => +(a / 256).toFixed(2);
const hexToRGBA = (hexArr) => {
    const [r, g, b, a] = hexArr.map(hexToDec);
    return [r, g, b, getAlphaFloat(a)];
};
function parseRGBA(color) {
    const rgba = RGBA_REGEX.exec(color);
    let r;
    let g;
    let b;
    let a;
    if (rgba) {
        [r, g, b, a] = rgba.slice(1, 5).map(parseFloat);
    }
    else if (isHex(color)) {
        const hexArray = separateHex(color.slice(1));
        if (!hexArray)
            return false;
        [r, g, b, a] = hexToRGBA(hexArray);
    }
    else
        return false;
    return { r, g, b, a };
}

const isHTMLOrSVG = (node) => node instanceof HTMLElement || node instanceof SVGElement;
function toKebab(str) {
    return str
        .split(/(?=[A-Z])/)
        .join('-')
        .toLowerCase();
}
function filterDataAttributes(element, filterFunction) {
    Object.keys(element.dataset).forEach(key => {
        const attr = `data-${toKebab(key)}`;
        if (attr.indexOf('data-illusory') === 0)
            return;
        if (!filterFunction || !filterFunction(attr))
            element.removeAttribute(attr);
    });
}
function copyStyles(source, target) {
    const styles = window.getComputedStyle(source);
    if (styles.cssText !== '')
        target.style.cssText = styles.cssText;
    else {
        let mockCssText = '';
        for (let i = 0; i < styles.length; i++) {
            mockCssText += `${styles[i]}: ${styles.getPropertyValue(styles[i])}; `;
        }
        target.style.cssText = mockCssText;
    }
    target.style.transformOrigin = styles.transformOrigin;
}
function duplicateNode(node, options, depth = 0) {
    let clone = node.cloneNode(false);
    if (isHTMLOrSVG(node)) {
        copyStyles(node, clone);
        if (options.preserveDataAttributes !== true)
            filterDataAttributes(clone, options.preserveDataAttributes);
    }
    if (typeof options.processClone === 'function') {
        const processedClone = options.processClone(clone, depth);
        if (processedClone)
            clone = processedClone;
        else
            return null;
    }
    if (options.includeChildren) {
        node.childNodes.forEach(child => {
            const duplicatedNode = duplicateNode(child, options, depth + 1);
            if (duplicatedNode)
                clone.appendChild(duplicatedNode);
        });
    }
    return clone;
}

function flushCSSUpdates(el1, el2) {
    el1.clone.clientWidth;
    el2 === null || el2 === void 0 ? void 0 : el2.clone.clientWidth;
}

function buildTransitionString(options) {
    if (options.compositeOnly)
        return `transform ${options.duration} ${options.easing} 0s, opacity ${options.duration} ${options.easing} 0s`;
    else
        return `all ${options.duration} ${options.easing} 0s`;
}

class IllusoryElement {
    constructor(el, options) {
        var _a, _b;
        this.originalStyle = {};
        this.deltaHandlers = {
            transform: transformHandler,
            borderTopLeftRadius: borderRadiusHandler,
            borderTopRightRadius: borderRadiusHandler,
            borderBottomRightRadius: borderRadiusHandler,
            borderBottomLeftRadius: borderRadiusHandler
        };
        this.isAttached = false;
        this.natural = el;
        this.initialStyleAttributeValue = this.natural.getAttribute('style');
        this._shouldIgnoreTransparency = (_a = options === null || options === void 0 ? void 0 : options.ignoreTransparency) !== null && _a !== void 0 ? _a : DEFAULT_OPTIONS.element.ignoreTransparency;
        this.natural.style.transition = 'none';
        this.natural.style.animation = 'none';
        {
            const originalNaturalTransform = this.natural.style.transform;
            this.natural.style.transform = 'none';
            this.rect = this.natural.getBoundingClientRect();
            this.natural.style.transform = originalNaturalTransform;
        }
        this.clone = duplicateNode(this.natural, {
            includeChildren: (_b = options === null || options === void 0 ? void 0 : options.includeChildren) !== null && _b !== void 0 ? _b : DEFAULT_OPTIONS.element.includeChildren,
            preserveDataAttributes: options === null || options === void 0 ? void 0 : options.preserveDataAttributes,
            processClone: options === null || options === void 0 ? void 0 : options.processClone
        });
        this.setStyle('left', 'auto');
        this.setStyle('right', 'auto');
        this.setStyle('top', 'auto');
        this.setStyle('bottom', 'auto');
        this.setStyle('margin', '0 0 0 0');
        this.setStyle('transition', 'none');
        this.setStyle('animation', 'none');
        this.setStyle('pointerEvents', 'none');
        this.setStyle('position', 'fixed');
        this.setStyle('left', `${this.rect.left}px`);
        this.setStyle('top', `${this.rect.top}px`);
        if (options === null || options === void 0 ? void 0 : options.attachImmediately)
            this.attach();
    }
    _makeCompositeOnly() {
        this.deltaHandlers = {
            transform: transformHandler,
            borderTopLeftRadius: DELTA_PASS_THROUGH_HANDLER,
            borderTopRightRadius: DELTA_PASS_THROUGH_HANDLER,
            borderBottomLeftRadius: DELTA_PASS_THROUGH_HANDLER,
            borderBottomRightRadius: DELTA_PASS_THROUGH_HANDLER
        };
    }
    get _ignoreTransparency() {
        if (this._shouldIgnoreTransparency === true)
            return true;
        if (Array.isArray(this._shouldIgnoreTransparency) &&
            this._shouldIgnoreTransparency.indexOf(this.clone.tagName.toLowerCase()) !== -1)
            return true;
        return false;
    }
    _hasTransparentBackground() {
        if (this._ignoreTransparency)
            return false;
        const rgba = parseRGBA(this.getStyle('backgroundColor'));
        if (!rgba)
            return false;
        return rgba.a < 1;
    }
    _to(element) {
        const delta = getDelta(this, element);
        Object.keys(this.deltaHandlers).forEach(key => {
            this.setStyle(key, this.deltaHandlers[key](delta, element.getStyle(key), this.getStyle(key)));
        });
    }
    _enableTransitions(options) {
        this.setStyle('transition', buildTransitionString(options));
    }
    _disableTransitions() {
        this.setStyle('transition', 'none');
    }
    _setParent(element) {
        if (this.isAttached)
            this.detach();
        this.hideNatural();
        element.appendChild(this.clone);
        this.isAttached = true;
    }
    _resetNaturalStyleAttribute() {
        if (!this.initialStyleAttributeValue)
            this.natural.removeAttribute('style');
        else
            this.natural.setAttribute('style', this.initialStyleAttributeValue);
    }
    getStyle(property) {
        var _a;
        return (_a = this.originalStyle[property]) !== null && _a !== void 0 ? _a : this.clone.style[property];
    }
    setStyle(property, value) {
        this.originalStyle[property] = this.getStyle(property);
        this.clone.style[property] = value;
    }
    waitFor(property) {
        return new Promise(resolve => {
            const cb = (e) => __awaiter(this, void 0, void 0, function* () {
                if (property !== 'any' && e.propertyName !== property)
                    return;
                if (property === 'any')
                    yield new Promise(r => requestAnimationFrame(r));
                this.clone.removeEventListener('transitionend', cb);
                resolve();
            });
            this.clone.addEventListener('transitionend', cb);
        });
    }
    hide() {
        this.setStyle('opacity', '0');
    }
    show() {
        this.setStyle('opacity', '1');
    }
    hideNatural() {
        this.natural.style.opacity = '0';
    }
    showNatural() {
        this.natural.style.opacity = '1';
    }
    flushCSS() {
        flushCSSUpdates(this);
    }
    attach() {
        this._setParent(document.body);
    }
    detach() {
        if (!this.isAttached)
            return;
        this.showNatural();
        this.flushCSS();
        this._resetNaturalStyleAttribute();
        this.clone.remove();
        this.isAttached = false;
    }
}

const targetManagers = new Map();
class TargetManager {
    constructor(target, listener) {
        this.listeners = [];
        this.initialPositions = new Map();
        this.target = target;
        this.add(listener);
    }
    static getCumulativeDelta(listener) {
        return listener.dependencies.reduce(({ x, y }, target) => {
            const delta = targetManagers.get(target).getDelta(listener);
            return {
                x: x + delta.x,
                y: y + delta.y
            };
        }, { x: 0, y: 0 });
    }
    get currentPosition() {
        return {
            x: this.target instanceof Document ? window.scrollX : this.target.scrollLeft,
            y: this.target instanceof Document ? window.scrollY : this.target.scrollTop
        };
    }
    getDelta(listener) {
        const initialPosition = this.initialPositions.get(listener);
        const currentPosition = this.currentPosition;
        return {
            x: initialPosition.x - currentPosition.x,
            y: initialPosition.y - currentPosition.y
        };
    }
    get listenerCount() {
        return this.listeners.length;
    }
    add(listener) {
        this.listeners.push(listener);
        this.initialPositions.set(listener, this.currentPosition);
    }
    remove(listener) {
        this.listeners.splice(this.listeners.indexOf(listener), 1);
        this.initialPositions.delete(listener);
    }
    dispatch() {
        this.listeners.forEach(listener => {
            const delta = TargetManager.getCumulativeDelta(listener);
            listener.handler(delta);
        });
    }
}
let debounce = false;
const scrollHandler = (e) => {
    if (debounce)
        return;
    debounce = true;
    requestAnimationFrame(() => {
        debounce = false;
        const target = e.target;
        if (!targetManagers.has(target))
            return;
        targetManagers.get(target).dispatch();
    });
};
var ScrollManager = {
    add(listener) {
        listener.dependencies.forEach(target => {
            if (!targetManagers.size)
                document.addEventListener('scroll', scrollHandler, true);
            if (targetManagers.has(target))
                targetManagers.get(target).add(listener);
            else
                targetManagers.set(target, new TargetManager(target, listener));
        });
    },
    remove(listener) {
        listener.dependencies.forEach(target => {
            const manager = targetManagers.get(target);
            manager.remove(listener);
            if (!manager.listenerCount)
                targetManagers.delete(target);
        });
        if (!targetManagers.size)
            document.removeEventListener('scroll', scrollHandler, true);
    }
};

function createContainer(opts) {
    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.top = '0';
    container.style.left = '0';
    container.style.zIndex = opts.zIndex.toString();
    container.style.transition = `opacity ${opts.duration} ${opts.easing} 0s`;
    document.body.appendChild(container);
    const scrollListener = {
        dependencies: opts.relativeTo,
        handler({ x, y }) {
            container.style.transform = `translate(${x}px, ${y}px)`;
        }
    };
    ScrollManager.add(scrollListener);
    return {
        setOpacity(opacity) {
            container.style.opacity = opacity;
        },
        add(start, end) {
            [start, end].forEach(el => {
                if (opts.compositeOnly)
                    el._makeCompositeOnly();
                el._setParent(container);
                el.setStyle('opacity', 1);
            });
        },
        destroy(start, end, canceled) {
            return __awaiter(this, void 0, void 0, function* () {
                if (typeof opts.beforeDetach === 'function') {
                    yield opts.beforeDetach(start, end, canceled);
                }
                ScrollManager.remove(scrollListener);
                start.detach();
                end.detach();
                container.remove();
            });
        }
    };
}

function illusory(from, to, options) {
    const opts = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    const convert = (target) => target instanceof IllusoryElement ? target : new IllusoryElement(target, opts.element);
    const start = convert(from);
    const end = convert(to);
    start.setStyle('zIndex', 1);
    end.setStyle('zIndex', 2);
    const container = createContainer(opts);
    container.add(start, end);
    container.setOpacity(start.getStyle('opacity'));
    const ref = {
        cancel: () => {
            throw new Error('Cancel called before assigned');
        }
    };
    return {
        finished: animate(start, end, container, opts, ref),
        cancel: () => {
            ref.cancel();
        }
    };
}
function animate(start, end, container, opts, cancelRef) {
    return new Promise((finished) => __awaiter(this, void 0, void 0, function* () {
        let canceled = false;
        const cancel = () => __awaiter(this, void 0, void 0, function* () {
            canceled = true;
            yield container.destroy(start, end, canceled);
            finished(canceled);
        });
        cancelRef.cancel = cancel;
        end.hide();
        end._to(start);
        if (typeof opts.beforeAnimate === 'function')
            yield Promise.resolve(opts.beforeAnimate(start, end));
        if (canceled)
            return;
        start._enableTransitions(opts);
        end._enableTransitions(opts);
        flushCSSUpdates(start, end);
        start._to(end);
        end._to(end);
        if (!end._ignoreTransparency && (end._hasTransparentBackground() || opts.compositeOnly))
            start.hide();
        end.show();
        container.setOpacity(end.getStyle('opacity'));
        yield end.waitFor('any');
        if (canceled)
            return;
        yield container.destroy(start, end, canceled);
        finished(canceled);
    }));
}

export { IllusoryElement, illusory };
